---
title: "Erlandson Figure Generation"
author: "Oceana"
date: "2/5/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Heavily based off of Holly's code.
Goals:
  1- Run Erlandson data through holly's code
      - explore the erlandson .csv file, determine its structure
              "*Tip - ecto root tip identification number*
              *Ecto_spp - species name, based on 97% sequence similarity, probably grouped using clustalw in geneious*
              *Genus - ecto genus*
              *Plot - plot identification number corresponding to plot numbers on map in supplement*
              *Site - this was the original plot identifier from a previous study.*
              *Salix.spp - willow species that the root came from*
              *Ind abund - tip abundance - this is a list of individual root tips, so the abundance is always 1.*
              *Plspp - original site identifier concatenated to the willow host species (for stats grouping)*
              *mean - mean depth to water table in summer months (june-august)*
              *Phylum -  phylum*
              *Order -  order*"
              
      - Run through a fungal traits db, assign traits?? 
        - Used fungaltraits and FunFun
        -DEEMY for rhizomorphs? 
          - may need to extract if rhizomorph true manually consulting DEEMY
          - can partially automate using holly's data (by genus)
      - Clean it, use Holly;s processing as an example
            1- Turn dataset into a matrix, retaining site id, species ID, tree??
            2- Create OTU table
      
  2 - Add the Erlandson dataset to the NMDS
      - involves generating a trait table
      - 
      
```{r message=FALSE}
library(vegan)
library(tidyverse)
```

#Read in Erlandson Matrices

```{r}
erlandson_OTU_raw <- read.csv(as.matrix("erlandson_OTU.csv")) %>% mutate(X=NULL)
erlandson_traits_raw <- read.csv(as.matrix("trait_OTU.csv")) %>% mutate(X=NULL)

# t/d save as and reload as R obj in matrices generation.rmd so no need to remove X column
```

# Refine matrices/Combine recurring taxa names beween 3 datasets
```{r warning=FALSE}
# Run against curated assembly (mendo) & ecto_OTUS (tejon) in Trait analysis folder
mendo_metadata <- read.csv("TraitAnalysisforOceana/Curated_Assembly_3July2012.csv")
tejon_metadata <- read.csv("TraitAnalysisforOceana/ecto_OTUs.csv") 
erlandson_metadata_raw <- read.csv("erlandson_generated_metadata.csv") 
erlandson_metadata <- erlandson_metadata_raw %>% drop_na(Ecto_ID)
mendo_names <- mendo_metadata %>% select(SpeciesCode, BlastID) #%>% mutate(Species = SpeciesCode)

tejon_names <- tejon_metadata %>% select(OUT_MatchwMendo,species) #%>% mutate (Species = OUT_MatchwMendo)
#Issue w tejon species format. Some NA's (replace w genus sp.), lots of genus sp. with additional codes. wouldnt it make more sense to leave them w special codes? - Yes

mendo_tejon_join <- bind_rows(mendo_names, tejon_names) %>% unite(Species, OUT_MatchwMendo, SpeciesCode) %>% unite(ID, species, BlastID)
mendo_tejon_join <- as.data.frame(mendo_tejon_join)
mendo_tejon_join$Species <- gsub("NA_", "", as.character(mendo_tejon_join$Species))
mendo_tejon_join$Species <- gsub("_NA", "", as.character(mendo_tejon_join$Species))
mendo_tejon_join$ID <- gsub("NA_", "", as.character(mendo_tejon_join$ID))
mendo_tejon_join$ID <- gsub("_NA", "", as.character(mendo_tejon_join$ID))
mendo_tejon_join$ID <- gsub("_", " ", as.character(mendo_tejon_join$ID))
mendo_tejon_join <- mendo_tejon_join[mendo_tejon_join$Species != "NA",]

ref_ID <- mendo_tejon_join
```

#Compare names of ERLANDSON dataset to existing 
```{r Erlandson for loop}
# Use erlandson_names
erlandson_metadata <- erlandson_metadata_raw %>% drop_na(Ecto_ID)

erlandson_names <- erlandson_metadata %>% select (Tree_site, Ecto_ID, Ecto_spp, Tip) %>% mutate(ref_name = numeric(nrow(.)))


for(i in 1:nrow(erlandson_names)) {
  for(j in 1:nrow(ref_ID)) {
    if(erlandson_names$Ecto_ID[i] == ref_ID$ID[j]) {
      erlandson_names$ref_name[i] = ref_ID$Species[j] 
      if(erlandson_names$ref_name[i] == 0) {
        erlandson_names$ref_name[i] = erlandson_names$Ecto_spp[i]
      }
  
      }
 
   }
}

erlandson_OTU <- erlandson_OTU_raw
erlandson_OTU_combined <- erlandson_OTU %>% 
  rename("17" = Cortinarius1,
         "3" = Cenococcum_geophilum)
# ADD new spp names to ref_ID

####

#now replace tree id w ref/species code then translate to columns in matrices ( for i in 1:ncol()
#transfer new species code (17, 3) to OTU matrix

#something that will work but is not scalable: df %>% rename (newname = oldname)


# match and replace IDs in OTU and trait matrices with mendo/tejon/ref codes

# %in% function may be faster erlandson_names$Ecto_ID[i] %in% ref_ID$ID
```

```{r Add dry/wet labels to tejon matrices}
label_erlandson <- erlandson_metadata %>% group_by(Plot, 
           mean, 
           Tree_site, 
           Ecto_spp) %>% 
  summarise(.) %>% 
  add_column(enviro = NA) %>% 
  mutate(enviro = if_else(mean < (-.5), "arid", "mesic")) %>% 
  ungroup()

erlandson_OTU_add_enviro <- label_erlandson %>% 
  select(Tree_site, enviro) %>% group_by(Tree_site, enviro) %>% 
  summarize(.) %>% 
  left_join(., erlandson_OTU_combined) %>% 
  ungroup() %>% 
  mutate(site = rep("erlandson", nrow(erlandson_OTU_combined))) %>% 
  relocate(site, .before = Tree_site)

#unique(label_erlandson$mean) #[1] -1.3 -1.0 -0.9 -0.4 -0.3 -0.1  0.1

# ****DETERMINE the cutoff for dry/wet. 7 variables so it wont be even split, 0.1 i believe may be "flooded" as described in paper. Suggested cutoff: <-0.5 = DRY/ARID, <-0.5 = WET/MESIC. I think this is fair as there is a pretty big jump in values between -.4 and -.9 which suggests this is intended by study design. Then only plots 1 & 2 are "dry"
```


#Relativize ERLANDSON Tables
```{r}
#ERLANDSON TRAITS

erlandson_traits <- erlandson_traits_raw %>% 
  mutate(short= contact + short,
         contact = NULL,
         rhizo= r_true,
         norhizo = r_false,
         r_true = NULL,
         r_false = NULL) %>% 
  relocate(short, .before = medium) %>% 
  relocate(norhizo, .before = rhizo)


erlandson_rel_traits <- erlandson_traits %>% 
  mutate(sumAbund = select(., short:rhizo) %>% 
             rowSums(na.rm = TRUE)) %>% 
  mutate(short = short/sumAbund, 
         medium = medium/sumAbund, 
         norhizo = norhizo/ sumAbund, 
         rhizo = rhizo/sumAbund) %>% 
  mutate(sumAbund = NULL)


#ERLANDSON OTU

erlandson_rel_OTU <- erlandson_OTU_add_enviro #%>%
    #mutate(sumAbund = select(., c(4:84,)) %>% 
     #        rowSums(na.rm = TRUE)) %>% 
  #relocate(sumAbund, .after = enviro) %>% 
  #mutate(sumAbund = NULL)
#ERlandson OTU is already relativized
```


# Read in TEJON data 
```{r}
tejon_traits <- read.csv("TraitAnalysisforOceana/ecto_OTU_traits.csv")
```

# Make rel abund table for Holly's data
```{r}
#And an update from Holly: The data she used weren’t relativized AT ALL (as far as she knows, although An’s sequence data probably were transformed somehow to get those weird decimals). For your metaanalysis, I think it will be important to convert Holly’s data to relative abundances before running the metaMDS().

#To do this, you can use the decostand() function in vegan:

#relativized_combo_matrix = decostand(combo.matrix, method = “total”)
```



## Tejon Data Cleaning (Holly)

```{r tejon data cleaning}

tejon.trees <- read_csv('TraitAnalysisforOceana/fungal-abundance.csv') #OTU table
tejon.ecto <- read.csv('TraitAnalysisforOceana/ecto_OTUs.csv') #OTU's of only EcM

#dim(tejon.trees)
#dim(tejon.ecto)
#head(tejon.ecto$OTU_ID)
#head(colnames(tejon.trees))
 
#tejon.trees_sum <- tejon.trees
#tejon.trees_sum<- rowSums(tejon.trees_sum[,3:2424]) # sum of abundances---**RELATIVIZE???**

tejon.trees <- tejon.trees[tejon.trees$site!='intermediate',] #removes intermediate site from OTU table

tejon.trees.ecto <- select(tejon.trees,tree, site) %>% cbind(tejon.trees[,colnames(tejon.trees) %in% tejon.ecto$OTU_ID])%>% 
  mutate(.,enviro = site,
         site = rep("tejon", nrow(tejon.trees))) %>% 
  relocate(site, .before = tree) %>% 
  relocate(enviro, .after = tree)


 
# Subset out just the Ecto data

#for(i in 1:dim(tejon.ecto)[1]){
	#OTU <- tejon.ecto$OTU_ID[i]
	
	#for(j in 1:dim(tejon.trees)[2]){
	#	if(colnames(tejon.trees)[j]==OTU){
	#		colnum <- j
	#	}
	#}
	
 # tejon.trees.ecto <- cbind(tejon.trees.ecto,tejon.trees[,colnum])
#}

#tejon.trees.ecto <- cbind(rep('tejon',dim(tejon.trees.ecto)[1]),tejon.trees.ecto)
#tail(tejon.trees.ecto)
#colnames(tejon.trees.ecto) <- c('site','tree','enviro',as.character(tejon.ecto$OUT_MatchwMendo))


write.csv(tejon.trees.ecto,'tejon_trees_ecto.csv')
#**might have to redo^ so arid = 1 and mesic = 3 --probablhy an ifelse command**

```

# Generate Trait Table (Holly)

```{r}
# Make a table that groups by traits, not OTUs

tejon.ecto.traits <-read.csv('TraitAnalysisforOceana/ecto_OTU_traits.csv')#trait + OTU, not a trait abundance matrix yet

tejon.ecto.traits$trait <- as.factor(tejon.ecto.traits$trait) # allows for levels cmd to work but may be a bad move?-addition by Oceana

#head(tejon.ecto.traits)
#levels(tejon.ecto.traits$trait) #[1] "exploration_type" "rhizomorphs"  

tejon.tree.traits <- tejon.trees.ecto %>% select(site, tree, enviro) %>% 
  mutate(short = 0,
         long = 0,
         medium = 0,
         norhizo = 0,
         rhizo = 0) 
  #subset out columns site, tree, enviro

#NEXT STEP is to fill trait columns w otuIDS
# Create new columns in df for traits
#tejon.tree.traits$short <- 0
#tejon.tree.traits$long <- 0
#tejon.tree.traits$medium <- 0
#tejon.tree.traits$norhizo <- 0
#tejon.tree.traits$rhizo <- 0

short <- tejon.ecto.traits[tejon.ecto.traits$type=='short',]$OTU_ID
medium <- tejon.ecto.traits[tejon.ecto.traits$type=='medium',]$OTU_ID
long <- tejon.ecto.traits[tejon.ecto.traits$type=='long distance',]$OTU_ID
rhizo <- tejon.ecto.traits[tejon.ecto.traits$type=='r_true',]$OTU_ID
norhizo <- tejon.ecto.traits[tejon.ecto.traits$type=='r_false',]$OTU_ID

#holly then writes the proceeding function to test
```


# Function to Test if Fungus has a trait
```{r may want to write a different method}

#OCHO roughhh interp: this function pulls in abundance data per OTU per tree(id hope), relating trait w OTU using tejon.ecto.traits table
#Continue to try to find a tidyverse way to pull in the above lines and this for loop
for(i in 4:dim(tejon.trees.ecto)[2]){
	# for each fungus
	# determine whether it is a short-dist forager
	hold <- rep(0, dim(tejon.trees.ecto)[1])
	
	if(colnames(tejon.trees.ecto)[i] %in% short){
	  hold <- tejon.trees.ecto[,i]
	}
	
	tejon.tree.traits$short <- tejon.tree.traits$short + hold

	# determine whether it is a medium-dist forager
	hold <- rep(0, dim(tejon.trees.ecto)[1])
	if(colnames(tejon.trees.ecto)[i] %in% medium){ hold <- tejon.trees.ecto[,i] }
	tejon.tree.traits$medium <- tejon.tree.traits$medium + hold

	# determine whether it is a long-dist forager
	hold <- rep(0, dim(tejon.trees.ecto)[1])
	if(colnames(tejon.trees.ecto)[i] %in% long){ hold <- tejon.trees.ecto[,i] }
	tejon.tree.traits$long <- tejon.tree.traits$long + hold
	
	# determine whether it makes rhizomorphs
	hold <- rep(0, dim(tejon.trees.ecto)[1])
	if(colnames(tejon.trees.ecto)[i] %in% rhizo){ hold <- tejon.trees.ecto[,i] }
	tejon.tree.traits$rhizo <- tejon.tree.traits$rhizo + hold
		
	# determine whether it doesn't make rhizomorphs
	hold <- rep(0, dim(tejon.trees.ecto)[1])
	if(colnames(tejon.trees.ecto)[i] %in% norhizo){ hold <- tejon.trees.ecto[,i] }
	tejon.tree.traits$norhizo <- tejon.tree.traits$norhizo + hold
	
}

#for now this function is better than anything I can make
```

#Relativize TEJON tables
```{r}
#TEJON TRAITS

tejon_rel_traits <- tejon.tree.traits %>%
    mutate(sumAbund = select(., short:rhizo) %>% 
             rowSums(na.rm = TRUE)) %>% 
  mutate(short = short/sumAbund, 
         long = long/sumAbund, 
         medium = medium/sumAbund, 
         norhizo = norhizo/ sumAbund, 
         rhizo = rhizo/sumAbund) %>% 
  mutate(sumAbund = NULL)


#TEJON OTU

tejon_rel_OTU <- tejon.trees.ecto %>%
    mutate(sumAbund = select(., c(4:120,)) %>% 
             rowSums(na.rm = TRUE)) %>% 
  relocate(sumAbund, .after = enviro)

for(i in 5:ncol(tejon_rel_OTU)) {
 tejon_rel_OTU[,i] <- tejon_rel_OTU[,i]/tejon_rel_OTU$sumAbund
  }
tejon_rel_OTU <- tejon_rel_OTU %>% 
  mutate(sumAbund = select(., c(5:121,)) %>% 
             rowSums(na.rm = TRUE)) %>% 
  mutate(sumAbund = NULL)

```



## Mendocino Data Cleaning (Holly)
```{r}
#read in files
pygmy.raw<-read.csv("TraitAnalysisforOceana/Curated_Assembly_3July2012.csv")
#head(pygmy.raw) #looks at first 6 lines
#names(pygmy.raw) #looks at variable names
pygmy.clean<-read.csv("TraitAnalysisforOceana/pygmy-cleandata-wsoils.csv")
#is.na(tail(pygmy.clean))
pygmy.crop <- pygmy.clean %>% group_by(SpeciesCode) %>% 
  arrange(., SpeciesCode) %>% ungroup()

#pyg.dropped <- subset(pygmy.crop[(475:490),]) # I dont know why these rows were dropped
# pygmy.crop<-pygmy.clean[order(pygmy.clean$SpeciesCode),]
#sort(unique(pygmy.clean$SpeciesCode))
#pygmy.crop[(470:490),(1:5)]
#pygmy.crop<-pygmy.crop[(1:475),]
# dim(pygmy.crop)


```

```{r}
#############Condensing to core by species
#names(pygmy.clean)
#pygmy_by_core <- pygmy.clean %>% 
 # group_by(No.Tips, Tree, SpeciesCode, Sample.ID) %>% 
  #summarise(No.Tips = sum(No.Tips))%>% 
  #distinct(No.Tips, .keep_all = TRUE)

#%>% mutate(#%>% select(Sample.ID, SpeciesCode,Tree, Core, Terrace, Pygmy, Trait.ForagingType, Trait.Hydrophobicity, Trait.Rhizomorphs)

#^^ above are oceana's attempts at tidyverse-ing the below chunk so far none as clean as Holly's 

pygmy.core<-aggregate(pygmy.clean$No.Tips,
                      list(pygmy.clean$Sample.ID,
                           pygmy.clean$SpeciesCode,
                           pygmy.clean$Tree,
                           pygmy.clean$Core,
                           pygmy.clean$Terrace,
                           pygmy.clean$Pygmy,
                           pygmy.clean$Trait.ForagingType,
                           pygmy.clean$Trait.Hydrophobicity,
                           pygmy.clean$Trait.Rhizomorphs)
                      ,sum)

colnames(pygmy.core)<-c("Sample.ID","SpeciesCode","Tree","Core","Terrace","Pygmy","Trait.ForagingType","Trait.Hydrophobicity","Trait.Rhizomorphs","Tips")
# ^ the above works better than what I can do
#head(pygmy.core)

pygmy.core<-cbind(pygmy.core,c(rep(1,dim(pygmy.core)[1])))

colnames(pygmy.core)<-c("Sample.ID","SpeciesCode","Tree","Core","Terrace","Pygmy","Trait.ForagingType","Trait.Hydrophobicity","Trait.Rhizomorphs","Tips","Spp")


#############Condensing to tree by species
names(pygmy.clean)

pygmy.tree<-aggregate(pygmy.clean$No.Tips,
                  list(pygmy.clean$SpeciesCode,
                    pygmy.clean$Tree,
                    pygmy.clean$Terrace,
                    pygmy.clean$Pygmy,
                    pygmy.clean$Trait.ForagingType,
                    pygmy.clean$Trait.Hydrophobicity,
                    pygmy.clean$Trait.Rhizomorphs)
                  ,sum)

colnames(pygmy.core)<-c("SpeciesCode","Tree","Terrace","Pygmy","Trait.ForagingType","Trait.Hydrophobicity","Trait.Rhizomorphs","Tips")

head(pygmy.tree)

pygmy.tree<-cbind(pygmy.tree,c(rep(1,dim(pygmy.tree)[1])))
colnames(pygmy.tree)<-c("SpeciesCode","Tree","Terrace","Pygmy","Trait.ForagingType","Trait.Hydrophobicity","Trait.Rhizomorphs","Tips","Spp")
tail(pygmy.tree)
```
# Holly's Functions

```{r species matrix function}

## species matrix function #####


#this code takes an input dataframe and makes it into
#a matrix that can be used for community similarity 

speciesMatrix<-function(data,species,abundance,sample.ID){
	
	speciesNames<-unique(data[[species]])
	sampleNames<-unique(data[[sample.ID]])
	
	speciesSummary<-aggregate(data[[abundance]],by=list(data[[species]]),FUN=sum,na.rm=TRUE)
	
	siteSummary<-aggregate(data[[abundance]], by=list(data[[sample.ID]]), FUN=sum, na.rm=TRUE)

	speciesByPlot<-aggregate(data[[abundance]], by=list(data[[sample.ID]],data[[species]]), FUN=sum, na.rm=TRUE)

	names(speciesByPlot)=c("sample","species","abundance")

	sppMat<-matrix(nrow=length(sampleNames),ncol=length(speciesNames))
	sppMat[is.na(sppMat)]=0	

	rownames(sppMat)<-sampleNames
	colnames(sppMat)<-speciesNames

	colNumbers<-match(speciesByPlot$species,speciesNames)
	rowNumbers<-match(speciesByPlot$sample,sampleNames)

for(i in 1:length(colNumbers)) {
	
	sppMat[rowNumbers[i],colNumbers[i]]=speciesByPlot$abundance[i]
	
	}

return(sppMat)


}

##END FUNCTION
```

#Create matrices from Holly's pygmy data
```{r}
#Ideally this will happen without Holly's speciesMatrix fxn

#Make Mendo OTU matrix
mendo_OTU_table <- pygmy.tree %>% 
  select(SpeciesCode, Tips, Tree) %>% 
  group_by(Tree) %>% 
  arrange(.,Tree) %>% 
  ungroup(Tree) %>% 
  pivot_wider(., names_from = SpeciesCode, values_from = Tips) %>% 
  mutate(Tree = NULL) %>% 
  replace(., is.na(.), 0)
  
mendo_OTU_matrix<- as.matrix(mendo_OTU_table)

## Make Mendo TRAIT matrix
mendo_trait_table_foraging <- pygmy.core %>% 
  select(Tree, Trait.ForagingType, Tips) %>% 
  group_by(Tree) %>% 
  arrange(Tree) %>% 
  ungroup() %>% 
  filter(., Trait.ForagingType != "") %>% 
  pivot_wider(., names_from = Trait.ForagingType, values_from = Tips)##why not working???
##^must be an issue w the fact that there are traits shared by multiple members under the same tree?

mendo_trait_table_rhizo <- pygmy.core %>% 
  select(Tree, Trait.Rhizomorphs, Tips) %>% 
  group_by(Tree) %>% 
  arrange(Tree) %>% 
  ungroup() %>% 
  filter(., Trait.Rhizomorphs != "") %>% 
  pivot_wider(., names_from = c(Trait.Rhizomorphs), values_from = c(Tips), values_fill = 0 )
```

# Applying Holly's speciesMatrix function
```{r}
#tree.matrix<-speciesMatrix(pygmy.clean,"SpeciesCode","No.Tips","Tree")
#dim(tree.matrix)  #Check to make sure there're 29 rows; if not...
#tree.matrix=tree.matrix[1:29,]

#^ the above makes a matrix, columns=SpeciesCode, rows=Tree (no identifying column), data = No.Tips

tree.trait.matrix<-cbind(speciesMatrix(pygmy.clean,"Trait.ForagingType","No.Tips","Tree"),speciesMatrix(pygmy.clean,"Trait.Hydrophobicity","No.Tips","Tree"),speciesMatrix(pygmy.clean,"Trait.Rhizomorphs","No.Tips","Tree"))

#head(tree.trait.matrix)
tree.trait.matrix<-tree.trait.matrix[,c(1:2,4:9,12:13)] # < cleans up weird columns generated by speciesMatrix function

#Condensed trait matrix to make all medium f-types into one column
#tree.trait.matrix.cond<-cbind(tree.trait.matrix[,1:2],rowSums(tree.trait.matrix[,3:5]),tree.trait.matrix[,6:10])


##the FOLLOWING appears to be something from another analysis missing "terrace"?
#Proportion of tips w/ traits
#trait_tip_count = tapply(tree.trait.matrix.cond[,1],terrace,FUN=sum)+tapply(tree.trait.matrix.cond[,2],terrace,FUN=sum)+tapply(tree.trait.matrix.cond[,3],terrace,FUN=sum)
#tip_count = tapply(rowSums(tree.matrix),terrace,FUN=sum)
#trait_tip_count/tip_count


#tip_count_trait=tapply(tree.trait.matrix.cond[,1],terrace,FUN=sum)+tapply(tree.trait.matrix.cond[,2],terrace,FUN=sum)+tapply(tree.trait.matrix.cond[,3],terrace,FUN=sum)
#tip_count = tapply(rowSums(tree.matrix),terrace,FUN=sum)
#tip_count_trait/tip_count 

```
#relativize MENDO matrices
```{r}

```

# Consolidate Matrices for Mendocino (pygmy) + Tejon

```{r}
OTU_list <- unique(c(colnames(tree.matrix),colnames(tejon.trees.ecto)[4:120]))
#length(OTU_list)
#makes list of OTUs in Mendo and Tejon datasets

tree_list <- 1:(dim(tejon.trees.ecto)[1]+dim(tree.matrix)[1])
#makes list of trees in Mendo and Tejon datasets

combo.matrix <- matrix(rep(0,length(tree_list)*length(OTU_list)),nrow=length(tree_list),ncol=length(OTU_list))
#creates empty matrix

#dim(combo.matrix)

colnames(combo.matrix) <- OTU_list
rownames(combo.matrix) <- tree_list

for(i in 1:dim(combo.matrix)[2]){
	OTU <- colnames(combo.matrix)[i]
	
	# Find OTU data for tejon
	colnum <- 0
	for(j in 1:dim(tejon.trees.ecto)[2]){
		if(colnames(tejon.trees.ecto)[j]==OTU){
			colnum <- j 	}	}	
	if(colnum==0){ 	tejon.abun <- rep(0,dim(tejon.trees.ecto)[1]) 	} 
	if(colnum!=0){ 	tejon.abun <- tejon.trees.ecto[,colnum] }

	# Find OTU data for mendocino	
	colnum <- 0
	for(j in 1:dim(tree.matrix)[2]){
		if(colnames(tree.matrix)[j]==OTU){
			colnum <- j  } 	}	
	if(colnum==0){	mendo.abun <- rep(0,dim(tree.matrix)[1]) 	} 
	if(colnum!=0){	mendo.abun <- tree.matrix[,colnum]	}
	
	combo.matrix[,i] <- c(tejon.abun,mendo.abun)
	
}


combo.trait.matrix <- matrix(rep(0,length(tree_list)*5),nrow=length(tree_list),ncol=5)
colnames(combo.trait.matrix) <- c('short','med','long','rhizo','norhizo')
rownames(combo.trait.matrix) <- tree_list

combo.trait.matrix <- as.data.frame(combo.trait.matrix)

head(tejon.tree.traits)
head(tree.trait.matrix.cond)
colnames(tree.trait.matrix.cond) <- c('short','long','med','contact','nohydro','hydro','norhizo','rhizo')
mendo.tree.traits <- as.data.frame(tree.trait.matrix.cond)
combo.trait.matrix$short <- c(tejon.tree.traits$short, mendo.tree.traits$short)
combo.trait.matrix$med <- c(tejon.tree.traits$medium,mendo.tree.traits$med)
combo.trait.matrix$long <- c(tejon.tree.traits$long,mendo.tree.traits$long)
combo.trait.matrix$rhizo <- c(tejon.tree.traits$rhizo,mendo.tree.traits$rhizo)
combo.trait.matrix$norhizo <- c(tejon.tree.traits$norhizo,mendo.tree.traits$norhizo)
```


## NMDS Code Tejon + Mendocino (Holly)

```{r message=FALSE, warning=FALSE}
require(vegan)
siteIDs <- c(rep(1,dim(tejon.trees.ecto)[1]),rep(2,dim(tree.matrix)[1]))

pygmy<-pygmy.clean$Pygmy[match(row.names(tree.matrix),pygmy.clean$Tree)]

aridIDs <- c(tejon.trees.ecto$enviro,pygmy)
for(i in 1:length(aridIDs)){if(aridIDs[i]==3){aridIDs[i]<-0}}

speciesNMDS <- metaMDS(as.matrix(combo.matrix),k=2,trymax=50)
traitNMDS <- metaMDS(as.matrix(combo.trait.matrix))

# quartz(height=4.2,width=8.7) # Mac OS graphics driver, doesnt work on PC
par(mar=c(4,4,1,1),mfrow=c(1,2))
plot(speciesNMDS$points[,1],speciesNMDS$points[,2],pch=c(21,22)[unclass(siteIDs)],main='OTUs',bg=c('black','white')[as.factor(aridIDs)],xlim=c(-2,2.2),cex=1.5,xlab='NMDS 1',ylab='NMDS 2');#legend(-1.6,2.1,c('Arid, Tejon','Wet, Tejon','Arid, Mendo.','Wet, Mendo.'),pch=c(21,21,22,22),pt.cex=1.5,pt.bg=c('white','black','white','black'))


plot(traitNMDS$points[,1], traitNMDS$points[,2],pch=c(21,22)[unclass(siteIDs)],main='Traits',bg=c('black','white')[as.factor(aridIDs)],ylim=c(-1,1.2),cex=1.5,xlab='NMDS 1',ylab='NMDS 2');legend(-1.3,1.25,c('Arid, Tejon','Wet, Tejon','Arid, Mendo.','Wet, Mendo.'),pch=c(21,21,22,22),pt.cex=1.5,pt.bg=c('white','black','white','black'),bg='white'); #ordiellipse(traitNMDS,aridIDs)

```
### APpendix##
```{r Surplus Code}

## Summary Table w/ Two Treatments ###


summary.table2<-function(dataset,response,treatments){	
mean.table<-aggregate(dataset[[response]],by=list(dataset[[treatments[1]]],dataset[[treatments[2]]]),mean,na.rm=TRUE)

std.table<-aggregate(dataset[[response]],by=list(dataset[[treatments[1]]],dataset[[treatments[2]]]),sd,na.rm=TRUE)

n.table<-aggregate(dataset[[response]],by=list(dataset[[treatments[1]]],dataset[[treatments[2]]]),length)

se.vector<-std.table$x/sqrt(n.table$x)

final.table<-cbind(mean.table,n.table$x,std.table$x,se.vector)
names(final.table)<-c("Group1","Group2","Mean","n","SD","SE")

return(final.table)

}


##END FUNCTION


## Summar Table w/ 1 Treatment #


summary.table1<-function(dataset,response,treatments){	
mean.table<-aggregate(dataset[[response]],by=list(dataset[[treatments]]),mean,na.rm=TRUE)

std.table<-aggregate(dataset[[response]],by=list(dataset[[treatments]]),sd,na.rm=TRUE)

n.table<-aggregate(dataset[[response]],by=list(dataset[[treatments]]),length)

se.vector<-std.table$x/sqrt(n.table$x)

final.table<-cbind(mean.table,n.table$x,std.table$x,se.vector)

names(final.table)<-c("Group1","Mean","n","SD","SE")

return(final.table)

}

##END FUNCTION


##Geodetic Distance from Matrix##

#Here is my program to compute geodetic inter-site distance matrix. Input requires *vectors* in degrees. 
#From http://www.biostat.umn.edu/~sudiptob/Software/distonearth.R

geodetic.distance.matrix <- function (long,lat) {		

NSITES <- length(lat)
R <- 6371

latitude <- lat	
longitude <- long	
latlong <- cbind(latitude, longitude)*pi/180	

d <- matrix(nrow=NSITES, ncol=NSITES)	

for(i in 1:(NSITES-1)) {	
d[i,i] <- 1.0		
	for (j in (i+1):NSITES) {					
	d[i,j] <- sin(latlong[i,1]) * sin(latlong[j,1]) + 			cos(latlong[i,1]) * cos(latlong[j,1])	*				cos(abs(latlong[i,2] - latlong[j,2]))
	d[j,i] <- d[i,j]
	}	
}
d[NSITES, NSITES] <- 1.0
d <- R*acos(d)
d

}
#####END FUNCTION




##Extract p-value from Linear Model


lmp <- function (modelobject) {
    if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
    f <- summary(modelobject)$fstatistic
    p <- pf(f[1],f[2],f[3],lower.tail=F)
    attributes(p) <- NULL
    return(p)
}
#####END FUNCTION
```
