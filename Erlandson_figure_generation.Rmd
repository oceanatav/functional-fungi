---
title: "Erlandson Figure Generation"
author: "Oceana"
date: "2/5/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Heavily based off of Holly's code.
Goals:
  1- Run Erlandson data through holly's code
      - explore the erlandson .csv file, determine its structure
              "*Tip - ecto root tip identification number*
              *Ecto_spp - species name, based on 97% sequence similarity, probably grouped using clustalw in geneious*
              *Genus - ecto genus*
              *Plot - plot identification number corresponding to plot numbers on map in supplement*
              *Site - this was the original plot identifier from a previous study.*
              *Salix.spp - willow species that the root came from*
              *Ind abund - tip abundance - this is a list of individual root tips, so the abundance is always 1.*
              *Plspp - original site identifier concatenated to the willow host species (for stats grouping)*
              *mean - mean depth to water table in summer months (june-august)*
              *Phylum -  phylum*
              *Order -  order*"
              
      - Run through a fungal traits db, assign traits?? 
        - Used fungaltraits and FunFun
        -DEEMY for rhizomorphs? 
          - may need to extract if rhizomorph true manually consulting DEEMY
          - can partially automate using holly's data (by genus)
      - Clean it, use Holly;s processing as an example
            1- Turn dataset into a matrix, retaining site id, species ID, tree??
            2- Create OTU table
      
  2 - Add the Erlandson dataset to the NMDS
      - involves generating a trait table
      - 
      
```{r message=FALSE}
library(vegan)
library(tidyverse)
#install.packages("BiocManager")
#library(BiocManager)
#BiocManager::install("phyloseq")
library(phyloseq)
```

#Read in Erlandson Matrices

```{r}
erlandson_OTU_raw <- read.csv(as.matrix("erlandson_OTU.csv")) %>% mutate(X=NULL)
erlandson_traits_raw <- read.csv(as.matrix("trait_OTU.csv")) %>% mutate(X=NULL)

# t/d save as and reload as R obj in matrices generation.rmd so no need to remove X column
```

# Refine matrices/Combine recurring taxa names beween 3 datasets
```{r warning=FALSE}
# Run against curated assembly (mendo) & ecto_OTUS (tejon) in Trait analysis folder
mendo_metadata <- read.csv("TraitAnalysisforOceana/Curated_Assembly_3July2012.csv")
tejon_metadata <- read.csv("TraitAnalysisforOceana/ecto_OTUs.csv") 
erlandson_metadata_raw <- read.csv("erlandson_generated_metadata.csv") 
erlandson_metadata <- erlandson_metadata_raw 
for(i in 1:nrow(erlandson_metadata)){
  if(erlandson_metadata$Ecto_spp[i] == "Clavulinopsis_helvola"){
    erlandson_metadata$Ecto_ID[i] = "Clavulinopsis helvola"
  }
  if(erlandson_metadata$Ecto_spp[i] == "Meliniomyces1"){
    erlandson_metadata$Ecto_ID[i] = "Meliniomyces sp."
  }
}
erlandson_metadata <- erlandson_metadata %>% drop_na(Ecto_ID)

mendo_names <- mendo_metadata %>% select(SpeciesCode, BlastID) #%>% mutate(Species = SpeciesCode)

tejon_names <- tejon_metadata %>% select(OUT_MatchwMendo,species) #%>% mutate (Species = OUT_MatchwMendo)
#Issue w tejon species format. Some NA's (replace w genus sp.), lots of genus sp. with additional codes. wouldnt it make more sense to leave them w special codes? - Yes

mendo_tejon_join <- bind_rows(mendo_names, tejon_names) %>% unite(Species, OUT_MatchwMendo, SpeciesCode) %>% unite(ID, species, BlastID)
mendo_tejon_join <- as.data.frame(mendo_tejon_join)
mendo_tejon_join$Species <- gsub("NA_", "", as.character(mendo_tejon_join$Species))
mendo_tejon_join$Species <- gsub("_NA", "", as.character(mendo_tejon_join$Species))
mendo_tejon_join$ID <- gsub("NA_", "", as.character(mendo_tejon_join$ID))
mendo_tejon_join$ID <- gsub("_NA", "", as.character(mendo_tejon_join$ID))
mendo_tejon_join$ID <- gsub("_", " ", as.character(mendo_tejon_join$ID))
mendo_tejon_join <- mendo_tejon_join[mendo_tejon_join$Species != "NA",]

ref_ID <- mendo_tejon_join %>% distinct()
```

#Compare names of ERLANDSON dataset to existing 
```{r Erlandson for loop}
# Use erlandson_names


erlandson_names <- erlandson_metadata %>% select (Tree_site, Ecto_ID, Ecto_spp, Tip) %>% mutate(ref_name = numeric(nrow(.)))


for(i in 1:nrow(erlandson_names)) {
  for(j in 1:nrow(ref_ID)) {
    if(erlandson_names$Ecto_ID[i] == ref_ID$ID[j]) {
      erlandson_names$ref_name[i] = ref_ID$Species[j] 
      if(erlandson_names$ref_name[i] == 0) {
        erlandson_names$ref_name[i] = erlandson_names$Ecto_spp[i]
      }
  
      }
 
   }
}

unique(erlandson_names$ref_name) # [1] "0"  "17" "3" #so the only matches were to Species Code/OTU "17" and "3"

#DONT FORGET TO WRITE SOMETHING THAT ADDS THE OTU COL AND ID TO REF_ID

erlandson_OTU <- erlandson_OTU_raw
erlandson_OTU_combined <- erlandson_OTU %>% select(order(colnames(.))) %>% 
  rename("17" = Cortinarius1,
         "3" = Cenococcum_geophilum)
# ADD new spp names to ref_ID

####

#now replace tree id w ref/species code then translate to columns in matrices ( for i in 1:ncol()
#transfer new species code (17, 3) to OTU matrix

#something that will work but is not scalable: df %>% rename (newname = oldname)


# match and replace IDs in OTU and trait matrices with mendo/tejon/ref codes

# %in% function may be faster erlandson_names$Ecto_ID[i] %in% ref_ID$ID
```

```{r Add dry/wet labels to erlandson matrices}
label_erlandson <- erlandson_metadata %>% group_by(Plot, 
           mean, 
           Tree_site, 
           Ecto_spp) %>% 
  summarise(.) %>% 
  add_column(enviro = NA) %>% 
  mutate(enviro = if_else(mean < (-.5), "arid", "mesic")) %>% 
  ungroup()

erlandson_OTU_add_enviro <- label_erlandson %>% 
  select(Tree_site, enviro) %>% group_by(Tree_site, enviro) %>% 
  summarize(.) %>% 
  left_join(., erlandson_OTU_combined) %>% 
  ungroup() %>% 
  mutate(site = rep("erlandson", nrow(erlandson_OTU_combined))) %>% 
  relocate(site, .before = Tree_site)

#unique(label_erlandson$mean) #[1] -1.3 -1.0 -0.9 -0.4 -0.3 -0.1  0.1

# ****DETERMINE the cutoff for dry/wet. 7 variables so it wont be even split, 0.1 i believe may be "flooded" as described in paper. Suggested cutoff: <-0.5 = DRY/ARID, <-0.5 = WET/MESIC. I think this is fair as there is a pretty big jump in values between -.4 and -.9 which suggests this is intended by study design. Then only plots 1 & 2 are "dry"
```


#Relativize ERLANDSON Tables
```{r}
#ERLANDSON TRAITS

erlandson_traits <- erlandson_traits_raw %>% 
  transmute(Tree_site = Tree_site,
            short= contact + short,
            medium = medium,
            long = rep(0),
            rhizo= r_true,
         norhizo = r_false)


erlandson_rel_traits <- erlandson_traits %>% 
  mutate(sumAbund = select(., short:norhizo) %>% 
             rowSums(na.rm = TRUE)) %>% 
  transmute(Tree = Tree_site,
            short = short/sumAbund, 
         medium = medium/sumAbund,
         long = long/sumAbund,
         norhizo = norhizo/ sumAbund, 
         rhizo = rhizo/sumAbund) %>% 
   group_by(Tree) %>% 
  summarise(short = sum(short),
           medium = sum(medium),
           long = sum(long),
           rhizo = sum(rhizo),
           norhizo = sum(norhizo)) %>% 
     column_to_rownames(., var = "Tree")


#ERLANDSON OTU

erlandson_rel_OTU <- erlandson_OTU_add_enviro %>% 
  select(-site, -enviro) 
erlandson_rel_OTU <- column_to_rownames(erlandson_rel_OTU, var = "Tree_site") 
#ERlandson OTU is already relativized

erlandson_tree_names <- unique(erlandson_OTU$Tree_site)
```

#Make ERLANDSON matrices
```{r}
erlandson_OTU_matrix <- as.matrix(erlandson_rel_OTU)
erlandson_trait_matrix <- as.matrix(erlandson_rel_traits)
```


# Read in TEJON data 
```{r}
tejon_traits <- read.csv("TraitAnalysisforOceana/ecto_OTU_traits.csv")
```

# Make rel abund table for Holly's data
```{r}
#And an update from Holly: The data she used weren’t relativized AT ALL (as far as she knows, although An’s sequence data probably were transformed somehow to get those weird decimals). For your metaanalysis, I think it will be important to convert Holly’s data to relative abundances before running the metaMDS().

#To do this, you can use the decostand() function in vegan:

#relativized_combo_matrix = decostand(combo.matrix, method = “total”)
```



## Tejon Data Cleaning (Holly)

```{r tejon data cleaning}

tejon.trees <- read_csv('TraitAnalysisforOceana/fungal-abundance.csv') #OTU table
tejon.ecto <- read.csv('TraitAnalysisforOceana/ecto_OTUs.csv') #OTU's of only EcM

#dim(tejon.trees)
#dim(tejon.ecto)
#head(tejon.ecto$OTU_ID)
#head(colnames(tejon.trees))
 
#tejon.trees_sum <- tejon.trees
#tejon.trees_sum<- rowSums(tejon.trees_sum[,3:2424]) # sum of abundances---**RELATIVIZE???**

tejon.trees <- tejon.trees[tejon.trees$site!='intermediate',] #removes intermediate site from OTU table

tejon.trees.ecto <- select(tejon.trees,tree, site) %>% cbind(tejon.trees[,colnames(tejon.trees) %in% tejon.ecto$OTU_ID])%>% 
  mutate(.,enviro = site,
         site = rep("tejon", nrow(tejon.trees))) %>% 
  relocate(site, .before = tree) %>% 
  relocate(enviro, .after = tree)


 
# Subset out just the Ecto data

#for(i in 1:dim(tejon.ecto)[1]){
	#OTU <- tejon.ecto$OTU_ID[i]
	
	#for(j in 1:dim(tejon.trees)[2]){
	#	if(colnames(tejon.trees)[j]==OTU){
	#		colnum <- j
	#	}
	#}
	
 # tejon.trees.ecto <- cbind(tejon.trees.ecto,tejon.trees[,colnum])
#}

#tejon.trees.ecto <- cbind(rep('tejon',dim(tejon.trees.ecto)[1]),tejon.trees.ecto)
#tail(tejon.trees.ecto)
#colnames(tejon.trees.ecto) <- c('site','tree','enviro',as.character(tejon.ecto$OUT_MatchwMendo))


write.csv(tejon.trees.ecto,'tejon_trees_ecto.csv')
#**might have to redo^ so arid = 1 and mesic = 3 --probablhy an ifelse command**

```

# Generate Trait Table (Holly)

```{r}
# Make a table that groups by traits, not OTUs

tejon.ecto.traits <-read.csv('TraitAnalysisforOceana/ecto_OTU_traits.csv')#trait + OTU, not a trait abundance matrix yet

tejon.ecto.traits$trait <- as.factor(tejon.ecto.traits$trait) # allows for levels cmd to work but may be a bad move?-addition by Oceana

#head(tejon.ecto.traits)
#levels(tejon.ecto.traits$trait) #[1] "exploration_type" "rhizomorphs"  

tejon.tree.traits <- tejon.trees.ecto %>% select(site, tree, enviro) %>% 
  mutate(short = 0,
         long = 0,
         medium = 0,
         norhizo = 0,
         rhizo = 0) 
  #subset out columns site, tree, enviro

#NEXT STEP is to fill trait columns w otuIDS
# Create new columns in df for traits
#tejon.tree.traits$short <- 0
#tejon.tree.traits$long <- 0
#tejon.tree.traits$medium <- 0
#tejon.tree.traits$norhizo <- 0
#tejon.tree.traits$rhizo <- 0

short <- tejon.ecto.traits[tejon.ecto.traits$type=='short',]$OTU_ID
medium <- tejon.ecto.traits[tejon.ecto.traits$type=='medium',]$OTU_ID
long <- tejon.ecto.traits[tejon.ecto.traits$type=='long distance',]$OTU_ID
rhizo <- tejon.ecto.traits[tejon.ecto.traits$type=='r_true',]$OTU_ID
norhizo <- tejon.ecto.traits[tejon.ecto.traits$type=='r_false',]$OTU_ID

#holly then writes the proceeding function to test
```


# Function to Test if Fungus has a trait
```{r may want to write a different method}

#roughhh interp: this function pulls in abundance data per OTU per tree(id hope), relating trait w OTU using tejon.ecto.traits table
#Continue to try to find a tidyverse way to pull in the above lines and this for loop
for(i in 4:dim(tejon.trees.ecto)[2]){
	# for each fungus
	# determine whether it is a short-dist forager
	hold <- rep(0, dim(tejon.trees.ecto)[1])
	
	if(colnames(tejon.trees.ecto)[i] %in% short){
	  hold <- tejon.trees.ecto[,i]
	}
	
	tejon.tree.traits$short <- tejon.tree.traits$short + hold

	# determine whether it is a medium-dist forager
	hold <- rep(0, dim(tejon.trees.ecto)[1])
	if(colnames(tejon.trees.ecto)[i] %in% medium){ hold <- tejon.trees.ecto[,i] }
	tejon.tree.traits$medium <- tejon.tree.traits$medium + hold

	# determine whether it is a long-dist forager
	hold <- rep(0, dim(tejon.trees.ecto)[1])
	if(colnames(tejon.trees.ecto)[i] %in% long){ hold <- tejon.trees.ecto[,i] }
	tejon.tree.traits$long <- tejon.tree.traits$long + hold
	
	# determine whether it makes rhizomorphs
	hold <- rep(0, dim(tejon.trees.ecto)[1])
	if(colnames(tejon.trees.ecto)[i] %in% rhizo){ hold <- tejon.trees.ecto[,i] }
	tejon.tree.traits$rhizo <- tejon.tree.traits$rhizo + hold
		
	# determine whether it doesn't make rhizomorphs
	hold <- rep(0, dim(tejon.trees.ecto)[1])
	if(colnames(tejon.trees.ecto)[i] %in% norhizo){ hold <- tejon.trees.ecto[,i] }
	tejon.tree.traits$norhizo <- tejon.tree.traits$norhizo + hold
	
}

#for now this function is better than anything I can make
```

#Relativize TEJON tables
```{r}
#TEJON TRAITS

tejon_rel_traits <- tejon.tree.traits %>%
    mutate(sumAbund = select(., short:rhizo) %>% 
             rowSums(na.rm = TRUE)) %>% 
  transmute(tree = tree,
         short = short/sumAbund, 
         long = long/sumAbund, 
         medium = medium/sumAbund, 
         norhizo = norhizo/ sumAbund, 
         rhizo = rhizo/sumAbund) %>% 
   group_by(tree) %>% 
  summarise(short = sum(short),
           medium = sum(medium),
           long = sum(long),
           rhizo = sum(rhizo),
           norhizo = sum(norhizo)) %>% 
     column_to_rownames(., var = "tree")

#TEJON OTU

tejon_rel_OTU <- tejon.trees.ecto %>%
    mutate(sumAbund = select(., c(4:120,)) %>% 
             rowSums(na.rm = TRUE)) %>% 
  relocate(sumAbund, .after = enviro)

for(i in 5:ncol(tejon_rel_OTU)) {
 tejon_rel_OTU[,i] <- tejon_rel_OTU[,i]/tejon_rel_OTU$sumAbund
  }
tejon_rel_OTU <- tejon_rel_OTU %>% 
  mutate(sumAbund = select(., c(5:121,)) %>% 
             rowSums(na.rm = TRUE)) %>% 
  mutate(sumAbund = NULL,
         site = NULL,
         enviro = NULL)
tejon_rel_OTU <- column_to_rownames(tejon_rel_OTU, var = "tree")

tejon_tree_names <- unique(rownames(tejon.trees.ecto$tree))
```
#TEJON matrices
```{r}
tejon_OTU_matrix <- as.matrix(tejon_rel_OTU)
tejon_trait_matrix <- as.matrix(tejon_rel_traits)
```



## Mendocino Data Cleaning (Holly)
```{r}
#read in files
pygmy.raw<-read.csv("TraitAnalysisforOceana/Curated_Assembly_3July2012.csv")
#head(pygmy.raw) #looks at first 6 lines
#names(pygmy.raw) #looks at variable names
pygmy.clean<-read.csv("TraitAnalysisforOceana/pygmy-cleandata-wsoils.csv")
#is.na(tail(pygmy.clean))
pygmy.crop <- pygmy.clean %>% group_by(SpeciesCode) %>% 
  arrange(., SpeciesCode) %>% ungroup()

#pyg.dropped <- subset(pygmy.crop[(475:490),]) # I dont know why these rows were dropped
# pygmy.crop<-pygmy.clean[order(pygmy.clean$SpeciesCode),]
#sort(unique(pygmy.clean$SpeciesCode))
#pygmy.crop[(470:490),(1:5)]
#pygmy.crop<-pygmy.crop[(1:475),]
# dim(pygmy.crop)


```

```{r}
#############Condensing to core by species
#names(pygmy.clean)
#pygmy_by_core <- pygmy.clean %>% 
 # group_by(No.Tips, Tree, SpeciesCode, Sample.ID) %>% 
  #summarise(No.Tips = sum(No.Tips))%>% 
  #distinct(No.Tips, .keep_all = TRUE)

#%>% mutate(#%>% select(Sample.ID, SpeciesCode,Tree, Core, Terrace, Pygmy, Trait.ForagingType, Trait.Hydrophobicity, Trait.Rhizomorphs)

#^^ above are oceana's attempts at tidyverse-ing the below chunk so far none as clean as Holly's 

pygmy.core<-aggregate(pygmy.clean$No.Tips,
                      list(pygmy.clean$Sample.ID,
                           pygmy.clean$SpeciesCode,
                           pygmy.clean$Tree,
                           pygmy.clean$Core,
                           pygmy.clean$Terrace,
                           pygmy.clean$Pygmy,
                           pygmy.clean$Trait.ForagingType,
                           pygmy.clean$Trait.Hydrophobicity,
                           pygmy.clean$Trait.Rhizomorphs)
                      ,sum)

colnames(pygmy.core)<-c("Sample.ID","SpeciesCode","Tree","Core","Terrace","Pygmy","Trait.ForagingType","Trait.Hydrophobicity","Trait.Rhizomorphs","Tips")
# ^ the above works better than what I can do
#head(pygmy.core)

pygmy.core<-cbind(pygmy.core,c(rep(1,dim(pygmy.core)[1])))

colnames(pygmy.core)<-c("Sample.ID","SpeciesCode","Tree","Core","Terrace","Pygmy","Trait.ForagingType","Trait.Hydrophobicity","Trait.Rhizomorphs","Tips","Spp")


#############Condensing to tree by species
names(pygmy.clean)

pygmy.tree<-aggregate(pygmy.clean$No.Tips,
                  list(pygmy.clean$SpeciesCode,
                    pygmy.clean$Tree,
                    pygmy.clean$Terrace,
                    pygmy.clean$Pygmy,
                    pygmy.clean$Trait.ForagingType,
                    pygmy.clean$Trait.Hydrophobicity,
                    pygmy.clean$Trait.Rhizomorphs)
                  ,sum)

#colnames(pygmy.core)<-c("SpeciesCode","Tree","Terrace","Pygmy","Trait.ForagingType","Trait.Hydrophobicity","Trait.Rhizomorphs","Tips")

head(pygmy.tree)

pygmy.tree<-cbind(pygmy.tree,c(rep(1,dim(pygmy.tree)[1])))
colnames(pygmy.tree)<-c("SpeciesCode","Tree","Terrace","Pygmy","Trait.ForagingType","Trait.Hydrophobicity","Trait.Rhizomorphs","Tips","Spp")
tail(pygmy.tree)
```
# Holly's Functions

```{r species matrix function}

## species matrix function #####


#this code takes an input dataframe and makes it into
#a matrix that can be used for community similarity 

#speciesMatrix<-function(data,species,abundance,sample.ID){
	
#	speciesNames<-unique(data[[species]])
#	sampleNames<-unique(data[[sample.ID]])
	
#	speciesSummary<-aggregate(data[[abundance]],by=list(data[[species]]),FUN=sum,na.rm=TRUE)
	
#	siteSummary<-aggregate(data[[abundance]], by=list(data[[sample.ID]]), FUN=sum, na.rm=TRUE)

#	speciesByPlot<-aggregate(data[[abundance]], by=list(data[[sample.ID]],data[[species]]), FUN=sum, na.rm=TRUE)

#	names(speciesByPlot)=c("sample","species","abundance")

#	sppMat<-matrix(nrow=length(sampleNames),ncol=length(speciesNames))
#	sppMat[is.na(sppMat)]=0	

#	rownames(sppMat)<-sampleNames
#	colnames(sppMat)<-speciesNames

#	colNumbers<-match(speciesByPlot$species,speciesNames)
#	rowNumbers<-match(speciesByPlot$sample,sampleNames)

#for(i in 1:length(colNumbers)) {
	
#	sppMat[rowNumbers[i],colNumbers[i]]=speciesByPlot$abundance[i]
	
#	}

#return(sppMat)


#}

##END FUNCTION
```
# Applying Holly's speciesMatrix function
```{r}
#tree.matrix<-speciesMatrix(pygmy.clean,"SpeciesCode","No.Tips","Tree")
#dim(tree.matrix)  #Check to make sure there're 29 rows; if not...
#tree.matrix=tree.matrix[1:29,]

#^ the above makes a matrix, columns=SpeciesCode, rows=Tree (no identifying column), data = No.Tips

#tree.trait.matrix<-cbind(speciesMatrix(pygmy.clean,"Trait.ForagingType","No.Tips","Tree"),speciesMatrix(pygmy.clean,"Trait.Hydrophobicity","No.Tips","Tree"),speciesMatrix(pygmy.clean,"Trait.Rhizomorphs","No.Tips","Tree"))

#head(tree.trait.matrix)
#tree.trait.matrix<-tree.trait.matrix[,c(1:2,4:9,12:13)] # < cleans up weird columns generated by speciesMatrix function

#Condensed trait matrix to make all medium f-types into one column
#tree.trait.matrix.cond<-cbind(tree.trait.matrix[,1:2],rowSums(tree.trait.matrix[,3:5]),tree.trait.matrix[,6:10])


##the FOLLOWING appears to be something from another analysis missing "terrace"?
#Proportion of tips w/ traits
#trait_tip_count = tapply(tree.trait.matrix.cond[,1],terrace,FUN=sum)+tapply(tree.trait.matrix.cond[,2],terrace,FUN=sum)+tapply(tree.trait.matrix.cond[,3],terrace,FUN=sum)
#tip_count = tapply(rowSums(tree.matrix),terrace,FUN=sum)
#trait_tip_count/tip_count


#tip_count_trait=tapply(tree.trait.matrix.cond[,1],terrace,FUN=sum)+tapply(tree.trait.matrix.cond[,2],terrace,FUN=sum)+tapply(tree.trait.matrix.cond[,3],terrace,FUN=sum)
#tip_count = tapply(rowSums(tree.matrix),terrace,FUN=sum)
#tip_count_trait/tip_count 

```


#Build MENDO tables
```{r}
#Ideally this will happen without Holly's speciesMatrix fxn

#Make Mendo OTU matrix
mendo_OTU_table <- pygmy.tree %>% 
  select(SpeciesCode, Tips, Tree) %>% 
  group_by(Tree) %>% 
  arrange(.,Tree) %>% 
  ungroup(Tree) %>% 
  pivot_wider(., names_from = SpeciesCode, values_from = Tips) %>% 
  replace(., is.na(.), 0)
  
#mendo_OTU_matrix<- as.matrix(mendo_OTU_table)

## Make Mendo TRAIT matrix
mendo_trait_table_foraging <- pygmy.core %>% 
  select(Tree, Trait.ForagingType, Tips) %>% 
  group_by(Tree) %>% 
  arrange(Tree) %>% 
  ungroup() %>% 
  filter(., Trait.ForagingType != "") %>% 
  mutate(row = row_number()) %>%
  pivot_wider(., names_from = Trait.ForagingType, values_from = Tips, values_fill = 0) %>% 
  transmute(Tree = Tree,
            short = shortdistance+contact, 
            medium = mediumdistancefringe+mediumdistancesmooth+mediumdistancemat,
            long = longdistance)
  
#not 100% sure what row_number does to help pivot.wider--but it works. Thanks stack overflow!

mendo_trait_table_rhizo <- pygmy.core %>% 
  select(Tree, Trait.Rhizomorphs, Tips) %>% 
  group_by(Tree) %>% 
  arrange(Tree) %>% 
  ungroup() %>% 
  filter(., Trait.Rhizomorphs != "") %>% 
    mutate(row = row_number()) %>%
  pivot_wider(., names_from = Trait.Rhizomorphs, values_from = Tips, values_fill = 0) %>% 
  transmute(Tree = Tree,
            norhizo = n,
            rhizo = y)# dropped m column, may have to revisit?

#Investigate "m" values for rhizomorphs
#pygmy_M = filter(pygmy.clean, Trait.Rhizomorphs == "m") # decided these were unknown, and to drop them.

mendo_trait_table <- left_join(mendo_trait_table_foraging, mendo_trait_table_rhizo) %>% 
   group_by(Tree) %>% 
  summarise(short = sum(short),
           medium = sum(medium),
           long = sum(long),
           rhizo = sum(rhizo),
           norhizo = sum(norhizo)) %>% 
     column_to_rownames(., var = "Tree")
#mendo_trait_matrix <- as.matrix(mendo_trait_table)
```


#Relativize MENDO tables
```{r}
#MENDO TRAITS

mendo_rel_traits <- mendo_trait_table %>%
    mutate(sumAbund = select(., short:rhizo) %>% 
             rowSums(na.rm = TRUE)) %>% 
  transmute(short = short/sumAbund, 
         medium = medium/sumAbund,
         long = long/sumAbund,
         norhizo = norhizo/ sumAbund, 
         rhizo = rhizo/sumAbund) 


#MENDO OTU

mendo_rel_OTU <- mendo_OTU_table %>%
    mutate(sumAbund = select(., c(2:83,)) %>% 
             rowSums(na.rm = TRUE)) #%>% 
  #relocate(sumAbund, .after = enviro)

for(i in 2:ncol(mendo_rel_OTU)) {
 mendo_rel_OTU[,i] <- mendo_rel_OTU[,i]/mendo_rel_OTU$sumAbund
  }

mendo_rel_OTU <- mendo_rel_OTU %>% 
  mutate(sumAbund = NULL)

mendo_rel_OTU <- column_to_rownames(mendo_rel_OTU, var = "Tree")  
```

#Generate Mendo Matrices
```{r}
mendo_OTU_matrix <- as.matrix(mendo_rel_OTU)
mendo_trait_matrix <- as.matrix(mendo_rel_traits)

```

#Combine Matrices to push to NMDS
```{r}
# try merge
#merge_erl <- merge(erlandson_OTU_matrix, mendo_OTU_matrix,)#combines columns of same name while converting their values to 0 which is not helpful to say the least. my ideal function adds, for example, the shared column 3 (cenococcum geophilum) from each matrix to each other. i dont know about join, maybe rbind?

#Just going to use Holly's code ftm

#She:
 # 1- makes vectors of columns and row names (including tree id) -we should use earlier dataframes. maybe thats more tidyverse-ible
#2- makes an empty mtrix
#3-transfers values from previously created matrices?
#  4-...easy enough to trim tree labels. 

#Combo OTU

  ##Make columns and rows
      ###Columns

OTU_list <- unique(c(colnames(mendo_OTU_matrix), colnames(tejon_OTU_matrix), colnames(erlandson_OTU_matrix)))

#Tree_names <- c(mendo_tree_names, tejon_tree_names, erlandson_tree_names)
#length(Tree_names)
#OTUlistdf <- as.data.frame(OTU_list) 
#View(OTUlistdf) #check names

      ###Rows
tree_names <- c(rownames(mendo_OTU_matrix), rownames(tejon_OTU_matrix), rownames(erlandson_OTU_matrix))
#tree_list <- 1:(dim(tejon_OTU_matrix)[1]+dim(mendo_OTU_matrix)[1] + dim(erlandson_OTU_matrix)[1])

  ##Make empty matrix the with our columns and rows

combo_OTU_matrix <- matrix(rep(0,length(tree_names)*length(OTU_list)),nrow=length(tree_names),ncol=length(OTU_list))

colnames(combo_OTU_matrix) <- OTU_list
rownames(combo_OTU_matrix) <- tree_names


  ## Now to fill in the values

for(i in 1:dim(combo_OTU_matrix)[2]){
	OTU <- colnames(combo_OTU_matrix)[i]
	
	# Find OTU data for tejon
	colnum <- 0
	for(j in 1:ncol(tejon_OTU_matrix)){
		if(colnames(tejon_OTU_matrix)[j]==OTU){
			colnum <- j 	}	}	
	if(colnum==0){ 	tejon.abun <- rep(0,nrow(tejon_OTU_matrix)) 	} 
	if(colnum!=0){ 	tejon.abun <- tejon_OTU_matrix[,colnum] }

	# Find OTU data for mendocino	
	colnum <- 0
	for(j in 1:dim(mendo_OTU_matrix)[2]){
		if(colnames(mendo_OTU_matrix)[j]==OTU){
			colnum <- j  } 	}	
	if(colnum==0){	mendo.abun <- rep(0,nrow(mendo_OTU_matrix)) 	} 
	if(colnum!=0){	mendo.abun <- mendo_OTU_matrix[,colnum]	}
	
	#Find OTU data for erlandson (Oceana)
	
	colnum <- 0
	for(j in 1:ncol(erlandson_OTU_matrix)) {
	  if(colnames(erlandson_OTU_matrix)[j]==OTU){
	    colnum <- j }	}
	if(colnum == 0){ erlandson.abun <- rep(0, nrow(erlandson_OTU_matrix))}
	if(colnum != 0){erlandson.abun <- erlandson_OTU_matrix[,colnum]}
	
	combo_OTU_matrix[,i] <- c(tejon.abun, mendo.abun, erlandson.abun)
	
}
# In the above for loop she creates an object (colnum). then loops through the columns of a site-specific matrix (eg tejon, mendocino, erlandson's study) and sets the object equal to that value (column name/OTU). if a column name matching that in the site-specific matrix is found, then colnum is not equal to zero and the data from that column (rows) are saved to an object (X.abun). ...

#Combo Traits

# tree_list can function as our rows, columns are all the same(short med long norhizo rhizo)

# cant i just rbind then--apparently not for 3 but tidyvers has bind_rows

#combo_trait_matrix <- bind_rows(mendo_trait_matrix,tejon_trait_matrix,erlandson_trait_matrix, .id=NULL)

combo_trait_matrix <- do.call("rbind", list(mendo_trait_matrix, tejon_trait_matrix,erlandson_trait_matrix))
# per stack overflow advice. 


#tax <- read_rds(file="taxa.rds")
#sam <- read_rds("144L_Exp_Processed_BactAbund.rds") %>% drop_na(DNA_SampleID) %>%column_to_rownames(var = "DNA_SampleID")
#OTU <- read_rds("seqtab-nochimtaxa.rds") 

```

# Consolidate Matrices for Mendocino (pygmy) + Tejon (Holly)

```{r}
#OTU_list <- unique(c(colnames(tree.matrix),colnames(tejon.trees.ecto)[4:120]))
#length(OTU_list)
#makes list of OTUs in Mendo and Tejon datasets

#tree_list <- 1:(dim(tejon_OTU_matrix)[1]+dim(mendo_OTU_matrix)[1])
#makes list of number of trees in Mendo and Tejon datasets (basically a list of 1-59)

#combo.matrix <- matrix(rep(0,length(tree_list)*length(OTU_list)),nrow=length(tree_list),ncol=length(OTU_list))
#creates empty matrix

#dim(combo.matrix)

#colnames(combo.matrix) <- OTU_list
#rownames(combo.matrix) <- tree_list

#for(i in 1:dim(combo.matrix)[2]){
#	OTU <- colnames(combo.matrix)[i]
	
	# Find OTU data for tejon
#	colnum <- 0
#	for(j in 1:dim(tejon.trees.ecto)[2]){
#		if(colnames(tejon.trees.ecto)[j]==OTU){
#			colnum <- j 	}	}	
#	if(colnum==0){ 	tejon.abun <- rep(0,dim(tejon.trees.ecto)[1]) 	} 
#	if(colnum!=0){ 	tejon.abun <- tejon.trees.ecto[,colnum] }

	# Find OTU data for mendocino	
#	colnum <- 0
#	for(j in 1:dim(tree.matrix)[2]){
#		if(colnames(tree.matrix)[j]==OTU){
#			colnum <- j  } 	}	
#	if(colnum==0){	mendo.abun <- rep(0,dim(tree.matrix)[1]) 	} 
#	if(colnum!=0){	mendo.abun <- tree.matrix[,colnum]	}
	
#	combo.matrix[,i] <- c(tejon.abun,mendo.abun)
	
#}


#combo.trait.matrix <- matrix(rep(0,length(tree_list)*5),nrow=length(tree_list),ncol=5)
#colnames(combo.trait.matrix) <- c('short','med','long','rhizo','norhizo')
#rownames(combo.trait.matrix) <- tree_list

#combo.trait.matrix <- as.data.frame(combo.trait.matrix)

#head(tejon.tree.traits)
#head(tree.trait.matrix.cond)
#colnames(tree.trait.matrix.cond) <- c('short','long','med','contact','nohydro','hydro','norhizo','rhizo')
#mendo.tree.traits <- as.data.frame(tree.trait.matrix.cond)
#combo.trait.matrix$short <- c(tejon.tree.traits$short, mendo.tree.traits$short)
#combo.trait.matrix$med <- c(tejon.tree.traits$medium,mendo.tree.traits$med)
#combo.trait.matrix$long <- c(tejon.tree.traits$long,mendo.tree.traits$long)
#combo.trait.matrix$rhizo <- c(tejon.tree.traits$rhizo,mendo.tree.traits$rhizo)
#combo.trait.matrix$norhizo <- c(tejon.tree.traits$norhizo,mendo.tree.traits$norhizo)
```
#Create PHYLOSEQ objects for OTU NMDS
https://joey711.github.io/phyloseq/import-data.html
```{r}
#ERLANDSON 
  ##Sample table
erl_sam <- erlandson_metadata %>% select(Tree_site, Plot, Site, Salix.spp, mean) %>% distinct() %>% column_to_rownames(., var = "Tree_site") %>%
  mutate(enviro = if_else(mean < (-.5), "arid", "mesic"),
         site = rep("cedar_creek")) 
#erl_sam <- sample_data(erl_sam)
  ##Taxa table
erl_tax <-erlandson_metadata %>% 
  select(Ecto_spp, Phylum, Order, Genus, Species, Subspecies, Ecto_ID) %>%
  arrange(Ecto_spp) %>% 
  mutate(Ecto_spp = replace(Ecto_spp, Ecto_spp == "Cortinarius1", "17"),
         Ecto_spp = replace(Ecto_spp, Ecto_spp == "Cenococcum_geophilum", "3")) %>% 
  distinct(.) %>%
  column_to_rownames(., var = "Ecto_spp")

#erl_ps <- phyloseq(erl_otu,erl_tax, erl_sam)
#sample_names(erl_ps)
#erl_ps_ord <- ordinate(erl_ps, method = "NMDS", distance = "bray")
#p_erl = plot_ordination(erl_ps, erl_ps_ord)
#print(p_erl)
#sample_names(erl_sam)
#erl_names <- colnames(erlandson_OTU_matrix)
#erl_tax_names <- erl_tax$Ecto_spp
#erl_names == erl_tax_names
#TEJON
  ##Sample table
tej_sam <- tejon.trees.ecto %>% 
  select(site, enviro, tree) %>% 
  distinct() %>%
  column_to_rownames(., var = "tree") 
  ##Taxa table
tej_tax <- tejon.ecto %>% select(OUT_MatchwMendo, kingdom,phylum,order,class, family,genus, species) %>% 
  distinct() %>%
  transmute(OUT_MatchwMendo = OUT_MatchwMendo,
          Kingdom = kingdom,
         Phylum = phylum,
         Order = order,
         Class = class,
         Family = family,
         Genus = genus,
         Species = species) %>% 
  column_to_rownames(., var = "OUT_MatchwMendo")
#MENDO
  ##Sample table
pygmy.clean$Tree <- as.character(pygmy.clean$Tree)
mendo_sam <- pygmy.clean %>% 
  select(Pygmy,Tree) %>% 
  distinct() %>%
  transmute(enviro = if_else(Pygmy == 1, "arid", "mesic"),
            Tree = Tree,
            site = rep("mendocino")) %>% 
  column_to_rownames(., var = "Tree")
  ##Taxa table
pygmy.clean$SpeciesCode <- as.character(pygmy.clean$SpeciesCode)
mendo_tax <- pygmy.clean %>% select(SpeciesCode, BlastID) %>% 
  separate(BlastID, into = c("Genus", "Species"), sep = "\\s")%>%
  distinct(., SpeciesCode) %>% 
  column_to_rownames(., var = "SpeciesCode")

#Combo
  ##OTU table
com_otu <- otu_table(combo_OTU_matrix, taxa_are_rows = F)
  ##"Taxa" table
com_tax <- bind_rows(tej_tax, mendo_tax, erl_tax)
com_tax <- tax_table(com_tax)
  ##Sample table
com_sam <- bind_rows(tej_sam, mendo_sam, erl_sam)
com_sam <- sample_data(com_sam)

com_ps <- phyloseq(com_otu,com_sam)
```
#Phyloseq objects for trait NMDS
```{r}
com_trait <- otu_table(combo_trait_matrix, taxa_are_rows = F)
Trait_tree_names <- c(rownames(combo_trait_matrix))
com_trait_tax <- as_tibble(combo_trait_matrix) #%>% mutate(trait = "")

for(i in 1:nrow(com_trait_tax)) {
  if(com_trait_tax$short[i] != 0){
    com_trait_tax$short[i] = "short"}
  if(com_trait_tax$medium[i] != 0){
    com_trait_tax$medium[i] = "medium"}
  if(com_trait_tax$long[i] != 0){
    com_trait_tax$long[i] = "long"}
  if(com_trait_tax$rhizo[i] != 0){
    com_trait_tax$rhizo[i] = "rhizo"}
  if(com_trait_tax$norhizo[i] != 0){
    com_trait_tax$norhizo[i] = "norhizo"
  }
}
com_tait_tax <-tax_table(com_trait_tax)
com_trait_ps <- phyloseq(com_sam, com_trait, com_trait_tax)
```

#Phyloseq NMDS
```{r}

#Taxonomy distribution
com_ps_ord <- ordinate(com_ps, method = "NMDS", distance = "bray")
p_com = plot_ordination(com_ps, com_ps_ord)
print(p_com)

p2_com = plot_ordination(com_ps, com_ps_ord, type="samples", color="enviro") 
print(p2_com)

p3_com = plot_ordination(com_ps, com_ps_ord, type="samples", color="site") 

print(p3_com)
#Trait distribution
com_trait_ps_ord <- ordinate(com_trait_ps, method = "NMDS", distance = "bray")
p_com_tr = plot_ordination(com_trait_ps, com_trait_ps_ord)
print(p_com_tr)

p2_com_tr = plot_ordination(com_trait_ps, com_trait_ps_ord, type="samples", color="enviro") 
print(p2_com_tr)
#TO PLOT BY TRAIT
#going to have to go back and take out line of code that sums tips abundances
#will have to make new unique rownames for samples, retaing (or creating) site column as well as enviro and unique trait.
p3_com_tr = plot_ordination(com_trait_ps, com_trait_ps_ord, type="taxa", color="enviro") 

print(p3_com)

```


#NMDS
```{r}
#https://rpubs.com/CPEL/NMDS
t_combo_OTU_matrix <- t(combo_OTU_matrix) 

df_t_combo <- as.data.frame(t_combo_OTU_matrix)
df_t_combo <- df_t_combo %>% mutate(sum = select(., 1:ncol(.)) %>% rowSums(na.rm = TRUE)) %>% filter(tibble_t_combo$sum == 0) 


spp <- colnames(combo_OTU_matrix)
OTU_NMDS <- metaMDS(as.matrix(df_t_combo), k = 2, distance = "bray")



trait_NMDS <- metaMDS(as.matrix(combo_trait_matrix), k = 2)
par(mfrow=c(1,2))
plot(OTU_NMDS, type = "t", display = c("site"))
stressplot(OTU_NMDS)
plot(trait_NMDS, type = "t", display = c("species"))

names(trait_NMDS)
#SHould I be inputting dissimilarity data instead???
#I can instead push this data thru the phyloseq package (short = species for trait table)
# Try phyloseq

#http://joey711.github.io/phyloseq-demo/phyloseq-demo.html # PHYLOSEQ DEMO

plot(pygmy.clean$OM.Pct)

```

## NMDS Code Tejon + Mendocino (Holly)

```{r message=FALSE, warning=FALSE}
require(vegan)
siteIDs <- c(rep(1,dim(tejon.trees.ecto)[1]),rep(2,dim(tree.matrix)[1]))

pygmy<-pygmy.clean$Pygmy[match(row.names(tree_names),pygmy.clean$Tree)]

aridIDs <- c(tejon.trees.ecto$enviro,pygmy)
for(i in 1:length(aridIDs)){if(aridIDs[i]==3){aridIDs[i]<-0}}

speciesNMDS <- metaMDS(as.matrix(combo.matrix),k=2,trymax=50)
traitNMDS <- metaMDS(as.matrix(combo.trait.matrix))

# quartz(height=4.2,width=8.7) # Mac OS graphics driver, doesnt work on PC
par(mar=c(4,4,1,1),mfrow=c(1,2))
plot(speciesNMDS$points[,1],speciesNMDS$points[,2],pch=c(21,22)[unclass(siteIDs)],main='OTUs',bg=c('black','white')[as.factor(aridIDs)],xlim=c(-2,2.2),cex=1.5,xlab='NMDS 1',ylab='NMDS 2');#legend(-1.6,2.1,c('Arid, Tejon','Wet, Tejon','Arid, Mendo.','Wet, Mendo.'),pch=c(21,21,22,22),pt.cex=1.5,pt.bg=c('white','black','white','black'))


plot(traitNMDS$points[,1], traitNMDS$points[,2],pch=c(21,22)[unclass(siteIDs)],main='Traits',bg=c('black','white')[as.factor(aridIDs)],ylim=c(-1,1.2),cex=1.5,xlab='NMDS 1',ylab='NMDS 2');legend(-1.3,1.25,c('Arid, Tejon','Wet, Tejon','Arid, Mendo.','Wet, Mendo.'),pch=c(21,21,22,22),pt.cex=1.5,pt.bg=c('white','black','white','black'),bg='white'); #ordiellipse(traitNMDS,aridIDs)

```
### Appendix##
```{r Surplus Code}

## Summary Table w/ Two Treatments ###


summary.table2<-function(dataset,response,treatments){	
mean.table<-aggregate(dataset[[response]],by=list(dataset[[treatments[1]]],dataset[[treatments[2]]]),mean,na.rm=TRUE)

std.table<-aggregate(dataset[[response]],by=list(dataset[[treatments[1]]],dataset[[treatments[2]]]),sd,na.rm=TRUE)

n.table<-aggregate(dataset[[response]],by=list(dataset[[treatments[1]]],dataset[[treatments[2]]]),length)

se.vector<-std.table$x/sqrt(n.table$x)

final.table<-cbind(mean.table,n.table$x,std.table$x,se.vector)
names(final.table)<-c("Group1","Group2","Mean","n","SD","SE")

return(final.table)

}


##END FUNCTION


## Summar Table w/ 1 Treatment #


summary.table1<-function(dataset,response,treatments){	
mean.table<-aggregate(dataset[[response]],by=list(dataset[[treatments]]),mean,na.rm=TRUE)

std.table<-aggregate(dataset[[response]],by=list(dataset[[treatments]]),sd,na.rm=TRUE)

n.table<-aggregate(dataset[[response]],by=list(dataset[[treatments]]),length)

se.vector<-std.table$x/sqrt(n.table$x)

final.table<-cbind(mean.table,n.table$x,std.table$x,se.vector)

names(final.table)<-c("Group1","Mean","n","SD","SE")

return(final.table)

}

##END FUNCTION


##Geodetic Distance from Matrix##

#Here is my program to compute geodetic inter-site distance matrix. Input requires *vectors* in degrees. 
#From http://www.biostat.umn.edu/~sudiptob/Software/distonearth.R

geodetic.distance.matrix <- function (long,lat) {		

NSITES <- length(lat)
R <- 6371

latitude <- lat	
longitude <- long	
latlong <- cbind(latitude, longitude)*pi/180	

d <- matrix(nrow=NSITES, ncol=NSITES)	

for(i in 1:(NSITES-1)) {	
d[i,i] <- 1.0		
	for (j in (i+1):NSITES) {					
	d[i,j] <- sin(latlong[i,1]) * sin(latlong[j,1]) + 			cos(latlong[i,1]) * cos(latlong[j,1])	*				cos(abs(latlong[i,2] - latlong[j,2]))
	d[j,i] <- d[i,j]
	}	
}
d[NSITES, NSITES] <- 1.0
d <- R*acos(d)
d

}
#####END FUNCTION




##Extract p-value from Linear Model


lmp <- function (modelobject) {
    if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
    f <- summary(modelobject)$fstatistic
    p <- pf(f[1],f[2],f[3],lower.tail=F)
    attributes(p) <- NULL
    return(p)
}
#####END FUNCTION
```
